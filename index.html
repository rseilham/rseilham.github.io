<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>Watson Assistant Chat</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    .WebChatContainer {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
  </style>
</head>
<body>
  
  <div class="WebChatContainer"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.21/jspdf.plugin.autotable.min.js"></script>
  
  <script>
    const customElement = document.querySelector('.WebChatContainer');
    const { jsPDF } = window.jspdf;
            // We are going to save the message history here.
            let messages = [];
            let agentMessages = [];
  
            /**
             * This function will save all the messages that came from session history. These are messages that are loaded if
             * the web page is re-loaded or the user navigates to a different page in the middle of a conversation. This does
             * not include messages with a human agent which are not stored in session history.
             */
            function saveHistory(event) {
                messages.push(...event.messages);
            }

            /**
             * This function will save each message that is generated by the send and receive events.
             */
            function saveMessage(event) {
                messages.push(event.data);
            }

            /**
             * This function will save each message that is generated by the send and receive events with a human agent.
             */
            function saveAgentMessage(event) {
                agentMessages.push({
                    ...event.data,
                    // Add the agent's nickname to this object to make it easier to process both the bot and agent messages.
                    agentNickname: (event.agentProfile && event.agentProfile.nickname) || 'Agent',
                });
            }

            async function onLoad(instance) {
                webChatInstance = instance;

                instance.on({ type: 'send', handler: saveMessage });
                instance.on({ type: 'receive', handler: saveMessage });
                instance.on({ type: 'history:begin', handler: saveHistory });
                instance.on({ type: 'view:change', handler: viewChangeHandler });

                // Add the custom menu option the user can use for both the bot and agent views.
                const additionalMenuOptions = [{
                            text: 'Download transcript',
                            handler: () => doDownload(createTranscriptDownload(), "Chat Transcript.pdf")
                        }
                    ]

                    instance.updateCustomMenuOptions('bot', additionalMenuOptions);
                    instance.updateCustomMenuOptions('agent', additionalMenuOptions);

                await instance.render();
            }

            /**
             * This function will be called when the user selects the "Download history" custom menu option.
             */
             function createTranscriptDownload() {
                const downloadLines = [createDownloadText('From', 'Message')];
                messages.forEach(message => {
                    if (message.input?.text) {
                        downloadLines.push(createDownloadText('User', message.input.text));
                    } else if (message.output?.generic?.length) {
                        message.output.generic.forEach(messageItem => {
                            if (messageItem?.text) {
                                downloadLines.push(createDownloadText('MyResource', messageItem.text));
                            }
                        });
                    }
                });
                return downloadLines.join('\n');
            }

            /**
             * Converts the given array of messages into an array of "lines" that will correspond to lines in the output file.
             */
            function messagesToLines(messages) {
                // We're going to create a comma-separate-value file (CSV). The first column will indicate if the message came
                // from the user or if it came from the bot. The second column will be the text of the message. This code here
                // only supports text responses but it can be updated to support additional types of messages such as "option"
                // responses (buttons and dropdowns) or "connect_to_agent" response. You can find more information about the
                // possible types of responses here: https://cloud.ibm.com/apidocs/assistant/assistant-v2#message-response.
                const downloadLines = [];
                console.info(messages);
                messages.forEach(message => {
                    if (message.input && message.input.text) {
                        // This is a message that came from the user.
                        let userName = 'You'
                        let userId = psuId;
                        if (userId) {
                            userName += " (" + userId + ")"
                        }
                        downloadLines.push(createDownloadText("you", message.input.text));
                    } else if (message.output && message.output.generic && message.output.generic.length) {
                        // This is a message that came from the assistant or an agent. It can contain an array of individual message items.
                        const systemName = message.agentNickname || 'Assistant';

                        message.output.generic.forEach(messageItem => {
                            switch (messageItem.response_type) {
                                case 'text': // Text reponse
                                    if (messageItem.text) {
                                        downloadLines.push(createDownloadText(systemName, messageItem.text))
                                    }
                                    break;

                                case 'option': // Array of options
                                    let optionsMessage = messageItem.options.filter(option => option.hasOwnProperty('label'))
                                        .map(option => option.label)
                                        .join(', ');
                                    downloadLines.push(createDownloadText(systemName, optionsMessage))
                                    break;

                                default: // If failed to detect response_type, parse it the same way as text response
                                    if (messageItem.text) {
                                        downloadLines.push(createDownloadText(systemName, messageItem.text))
                                    }
                            }
                        });
                    }
                });

                return downloadLines;
            }

            /**
             * This function will perform a download of the user's chat history. This is called when the user chooses the
             * custom option from the menu.
             */
             async function doDownload(downloadContent, name) {
                const doc = new jsPDF();
                const columns = [{ header: 'From', dataKey: 'from' }, { header: 'Message', dataKey: 'message' }];
                
                const rows = downloadContent.split('\n').map((line, index) => {
                    if (index === 0) return null; // Skip the header line
                    const [from, message] = line.split(',', 2);
                    return { from, message };
                }).filter(row => row); // Filter out the null value from the header line

                doc.autoTable({
                    head: [columns.map(col => col.header)],
                    body: rows.map(row => [row.from, row.message]),
                    startY: 20,
                    theme: 'striped',
                    margin: { top: 10 },
                    styles: { cellPadding: 5, fontSize: 10, valign: 'middle' },
                    columnStyles: { 0: { cellWidth: 'auto' }, 1: { cellWidth: 'auto' } }
                });

                doc.save(name);
            }

            /**
             * Escapes the given piece of text so it can safely be displayed in a CSV file.
             */
            function escapeCSV(text) {
                // Remove any newline characters which aren't supported in all CSV formats.
                text = text.toString().replace(/\n/g, ' ');

                // If the text contains a comma or a double quote, the entire thing needs to be surrounded by double quotes. If
                // the string contains a double quote, then each double quote needs to be replaced with two double quotes.
                if (text.match(/[,"]/)) {
                    return `"${text.replace(/"/g, '""')}"`;
                }
                return text;
            }

            /**
             * Creates a single row of text that will appear in the output file.
             */
            function createDownloadText(from, text) {
                return `${from},${escapeCSV(text)}`;
            }

            function customResponseHandler(event) {
                const { message, fullMessage, element } = event.data;

                if (message.user_defined) {
                    message.fullWidth = true;
                    let candidates = message.user_defined.candidates;

                    // Convert using 
                    element.innerHTML = `<div class="ibm-web-chat--default-styles">
                        To download list as CSV <a id="csv-export">Click here</a>
                    </div>`;

                    const exportButton = element.querySelector('#csv-export')
                    exportButton.addEventListener('click', () => doDownload(jsonToCsv(candidates), "Exported List.csv", "text/csv"));
                }
            }

            function jsonToCsv(jsonObjects) {
                if (!jsonObjects || jsonObjects.length === 0) {
                    return ''; // If the list is empty, return an empty string
                }

                const keys = Object.keys(jsonObjects[0]); // Extract keys from the first object
                const formatedKeys = keys.map(key => formatTableColumnKey(key));

                let csv = formatedKeys.join(',') + '\n';

                jsonObjects.forEach(obj => {
                    const row = keys.map(key => escapeCSV(obj[key])).join(',');
                    csv += row + '\n';
                });

                return csv;
            }

    /**
     * This function is called after a view change has occurred. It will show or hide the main window element.
     */
    function viewChangeHandler(event, instance) {
      if (event.newViewState.mainWindow) {
        // Note that we have to hide the main window instead of WebChatContainer because the custom element hosts both
        // the main web chat window and the launcher. If we hide the entire container, then we will hide the launcher
        // too.
        instance.elements.getMainWindow().removeClassName('HideWebChat');
      } else {
        instance.elements.getMainWindow().addClassName('HideWebChat');
      }
    }

    // This is the standard web chat configuration object. You can modify these values with the embed code for your
    // own assistant if you wish to try this example with your assistant. You can find the documentation for this at
    // https://web-chat.global.assistant.watson.cloud.ibm.com/docs.html?to=api-configuration#configurationobject.
    window.watsonAssistantChatOptions = {
        integrationID: "3c8d5d1e-f7cb-4632-b975-4da305b2abe8",
        region: "us-east",
        serviceInstanceID: "737c6533-0442-4420-b341-66368cbe4b6c",
        subscriptionID: "0e1a6bca95e045edb0231fc92b3e5ca8",
      // This is where we provide the custom element to web chat so it knows where it is supposed to be placed.
        element: customElement,
        openChatByDefault: true,
        hideCloseButton: true,
        disableCustomElementMobileEnhancements: true,
      onLoad: onLoad,
    };
    setTimeout(function(){const t=document.createElement('script');t.src="https://web-chat.global.assistant.watson.appdomain.cloud/versions/" + (window.watsonAssistantChatOptions.clientVersion || 'latest') + "/WatsonAssistantChatEntry.js";document.head.appendChild(t);});
  </script>
</body>
</html>
